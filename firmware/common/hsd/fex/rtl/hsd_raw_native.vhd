-- ==============================================================
-- RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2016.4
-- Copyright (C) 1986-2017 Xilinx, Inc. All Rights Reserved.
-- 
-- ===========================================================

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
use IEEE.numeric_std.all;
use work.StdRtlPkg.all;
use work.AxiLitePkg.all;

entity hsd_raw_native is
generic (
    C_S_AXI_BUS_A_ADDR_WIDTH : INTEGER := 5;
    C_S_AXI_BUS_A_DATA_WIDTH : INTEGER := 32 );
port (
    ap_clk   : IN STD_LOGIC;
    ap_rst_n : IN STD_LOGIC;
    sync     : IN  STD_LOGIC;
    x        : in  Slv11Array(7 downto 0);
    tin      : in  Slv2Array (7 downto 0);
    y        : out Slv16Array(8 downto 0);
    tout     : out Slv2Array (8 downto 0);
    yv       : out slv       (3 downto 0);
    axilReadMaster  : in  AxiLiteReadMasterType;
    axilReadSlave   : out AxiLiteReadSlaveType;
    axilWriteMaster : in  AxiLiteWriteMasterType;
    axilWriteSlave  : out AxiLiteWriteSlaveType );
end;


architecture behav of hsd_raw_native is

  type RegType is record
    count      : slv(8 downto 0);
    count_last : slv(8 downto 0);
    nopen      : slv(4 downto 0);
    lskip      : sl;
    y          : Slv16Array(8 downto 0);
    t          : Slv2Array (8 downto 0);
    yv         : slv       (3 downto 0);
  end record;

  constant REG_INIT_C : RegType := (
    count      => (others=>'0'),
    count_last => (others=>'0'),
    nopen      => (others=>'0'),
    lskip      => '0',
    y          => (others=>(others=>'0')),
    t          => (others=>(others=>'0')),
    yv         => (others=>'0') );

  signal r    : RegType := REG_INIT_C;
  signal r_in : RegType;

begin

  axilReadSlave  <= AXI_LITE_READ_SLAVE_EMPTY_OK_C;
  axilWriteSlave <= AXI_LITE_WRITE_SLAVE_EMPTY_OK_C;
  
  comb : process ( sync, r, x, tin ) is
    variable v      : RegType;
    variable tsum   : slv(1 downto 0);
    variable dcount : slv(8 downto 0);
  begin
    v := r;

    -- default response
    for i in 0 to 7 loop
      v.y(i) := toSlv(0,5) & x(i);
    end loop;
    v.y(8) := x"8000";
    v.t    := "00" & tin;
    
    tsum   := "00";
    for i in 0 to 7 loop
      tsum := tsum or tin(i);
    end loop;

    dcount := r.count - r.count_last;
    
    if r.lskip = '1' then
      v.y(0) := '1' & toSlv(0,6) & dcount;
      v.t(0) := "00";
      for i in 0 to 7 loop
        v.y(i+1) := toSlv(0,5) & x(i);
        v.t(i+1) := tin(i);
      end loop;

      if tsum(0) = '1' then
        v.yv         := toSlv(9,4);
        v.count_last := r.count+7;
        v.lskip      := '0';
      elsif dcount(8) = '1' then
        --  We don't really need this character (no gate is open)
        v.yv         := toSlv(1,4);
        v.count_last := r.count;
      else
        v.yv         := toSlv(0,4);
      end if;
    elsif r.nopen /= 0 then
      v.yv         := toSlv(8,4);
      v.count_last := r.count+7;
    else
      v.yv    := toSlv(0,4);
      v.lskip := '1';
    end if;

    if tsum = "01" then
      v.nopen := r.nopen+1;
    elsif tsum = "10" then
      v.nopen := r.nopen-1;
    end if;

    v.count := r.count + 8;

    y    <= r.y;
    yv   <= r.yv;
    tout <= r.t;
    
    if sync = '1' then
      v := REG_INIT_C;
    end if;

    r_in <= v;
  end process comb;

  seq : process ( ap_clk ) is
  begin
    if rising_edge(ap_clk) then
      r <= r_in;
    end if;
  end process seq;

end behav;
