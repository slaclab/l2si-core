-- ==============================================================
-- RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2016.4
-- Copyright (C) 1986-2017 Xilinx, Inc. All Rights Reserved.
-- 
-- ===========================================================

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.numeric_std.all;
use work.StdRtlPkg.all;
use work.AxiLitePkg.all;

entity hsd_thr_native is
generic (
    C_S_AXI_BUS_A_ADDR_WIDTH : INTEGER := 6;
    C_S_AXI_BUS_A_DATA_WIDTH : INTEGER := 32 );
port (
    ap_clk   : IN STD_LOGIC;
    ap_rst_n : IN STD_LOGIC;
    sync     : IN  STD_LOGIC;
    x        : in  Slv11Array(7 downto 0);
    tin      : in  Slv2Array (7 downto 0);
    y        : out Slv16Array(8 downto 0);
    tout     : out Slv2Array (8 downto 0);
    yv       : out slv       (3 downto 0);
    axilReadMaster  : in  AxiLiteReadMasterType;
    axilReadSlave   : out AxiLiteReadSlaveType;
    axilWriteMaster : in  AxiLiteWriteMasterType;
    axilWriteSlave  : out AxiLiteWriteSlaveType );

end;

architecture behav of hsd_thr_native is
  
  type RegType is record
    xlo        : slv(10 downto 0);
    xhi        : slv(10 downto 0);
    tpre       : slv( 3 downto 0);
    tpost      : slv( 3 downto 0);
    sync       : sl;
    
    count      : slv(8 downto 0);
    count_last : slv(8 downto 0);
    nopen      : slv(4 downto 0);
    lskip      : sl;

    waddr      : slv( 3 downto 0);
    raddr      : slv( 3 downto 0);
    akeep      : slv(15 downto 0);
    keepm      : slv(15 downto 0);
    
    y          : Slv16Array(8 downto 0);
    t          : Slv2Array (8 downto 0);
    yv         : slv       (3 downto 0);
    readSlave  : AxiLiteReadSlaveType;
    writeSlave : AxiLiteWriteSlaveType;
  end record;

  constant REG_INIT_C : RegType := (
    xlo        => toSlv(512,11),
    xhi        => toSlv(512,11),
    tpre       => toSlv(  1,4),
    tpost      => toSlv(  1,4),
    sync       => '1',
    
    count      => (others=>'0'),
    count_last => (others=>'0'),
    nopen      => (others=>'0'),
    lskip      => '0',

    waddr      => (others=>'0'),
    raddr      => (others=>'0'),
    akeep      => (others=>'0'),
    keepm      => (others=>'0'),
    
    y          => (others=>(others=>'0')),
    t          => (others=>(others=>'0')),
    yv         => (others=>'0'),
    readSlave  => AXI_LITE_READ_SLAVE_INIT_C,
    writeSlave => AXI_LITE_WRITE_SLAVE_INIT_C );

  signal r    : RegType := REG_INIT_C;
  signal r_in : RegType;

  signal xsave : Slv11Array(7 downto 0);
  signal tsave : Slv2Array (7 downto 0);
  
begin

  GEN_RAM : for i in 0 to 7 generate
    U_RAM : entity work.SimpleDualPortRam
      generic map ( DATA_WIDTH_G => 13,
                    ADDR_WIDTH_G => 4 )
      port map ( clka                => ap_clk,
                 wea                 => '1',
                 addra               => r.waddr,
                 dina(10 downto  0)  => x(i),
                 dina(12 downto 11)  => tin(i),
                 clkb                => ap_clk,
                 addrb               => r.raddr,
                 doutb(10 downto  0) => xsave(i),
                 doutb(12 downto 11) => tsave(i) );
  end generate;
  
  comb : process ( ap_rst_n, r, x, t, xsave, tsave ) is
    variable v      : RegType;
    variable ep     : AxiLiteEndPointType;
    variable tsum   : slv(1 downto 0);
    variable iopen  : integer;
    variable lout   : sl;
    variable lkeep  : sl;
    variable dcount : slv(8 downto 0);
  begin
    v := r;

    -- AxiLite accesses
    axiSlaveWaitTxn( ep,
                     axilWriteMaster, axilReadMaster,
                     v.writeSlave, v.readSlave );

    v.readSlave.rdata := (others=>'0');
      
    axiSlaveRegister ( ep, x"00", 0, v.xlo   );
    axiSlaveRegister ( ep, x"04", 0, v.xhi   );
    axiSlaveRegister ( ep, x"08", 0, v.tpre  );
    axiSlaveRegister ( ep, x"0C", 0, v.tpost );

    v.sync := '0';
    axiWrDetect(ep, x"08", v.sync);
    axiWrDetect(ep, x"0C", v.sync);
    
    axiSlaveDefault( ep, v.writeSlave, v.readSlave );

    axilWriteSlave <= r.writeSlave;
    axilReadSlave  <= r.readSlave;

    v.keepm := (others=>'0');
    for i in r.keepm'range loop
      if (i < conv_integer(r.tpre)+conv_integer(r.tpost)) then
        v.keepm(i) := '1';
      end if;
    end loop;

    lkeep := '0';
    for i in 0 to 7 loop
      if ((x(i) < r.xlo) or (x(i) > r.xhi)) then
        lkeep := '1';
      end if;
    end loop;

    if lkeep = '1' then
      v.akeep := v.akeep or r.keepm;
    end if;
    v.akeep := '0' & v.akeep(r.akeep'left downto 1);

    lout := lkeep or r.akeep(0);
    
    -- default response
    for i in 0 to 7 loop
      v.y(i) := resize(x(i),16);
    end loop;
    v.y(8) := x"8000";
    v.t    := "00" & tin;
    
    tsum := "00";
    iopen := 0;
    for i in 0 to 7 loop
      tsum := tsum or tin(i);
      if tin(i)(0) = '1' then
        iopen := i;
      end if;
    end loop;

    dcount := r.count - r.count_last;

    if ((r.nopen or tsum(0)) and lout='1') then
      if r.lskip = '1' then
        -- skip to the first position
        v.y(0) := '1' & resize(dcount,15);
        v.t(0) := "00";
        for i in 0 to 7 loop
          v.y(i+1) := resize(xsave(i),16);
          v.t(i+1) := tsave(i);
        end loop;
        v.yv   := toSlv(9,4);
      else
        for i in 0 to 7 loop
          v.y(i) := resize(xsave(i),16);
          v.t(i) := tsave(i);
        end loop;
        v.yv   := toSlv(8,4);
      end if;
      v.count_last := r.count+7;
      v.lskip      := '0';
    elsif (tsum/="00" or dcount(8)='1') then
      -- skip to the opening position
      v.y(0) := '1' & resize(dcount+iopen,15);
      v.t(0) := tsum;
      for i in 0 to 7 loop
        v.y(i+1) := resize(xsave(i),16);
        v.t(i+1) := tsave(i);
      end loop;
      v.yv   := toSlv(1,4);
      v.count_last := r.count + iopen;
      if iopen < 7 then
        v.lskip := '1';
      else
        v.lskip := '0';
      end if;
    else
      -- skip to the first position
      v.y(0) := '1' & resize(dcount-1,15);
      v.t(0) := tsum;
      for i in 0 to 7 loop
        v.y(i+1) := resize(xsave(i),16);
        v.t(i+1) := tsave(i);
      end loop;
      v.yv   := toSlv(0,4);
      v.lskip := '1';
    end if;

    if r.sync = '1' then
      v.waddr := r.tpre;
      v.raddr := (others=>'0');
    else
      v.waddr := r.waddr + 1;
      v.raddr := r.raddr + 1;
    end if;
    
    if tsum = "01" then
      v.nopen := r.nopen+1;
    elsif tsum = "10" then
      v.nopen := r.nopen-1;
    end if;

    v.count := r.count + 8;

    y    <= r.y;
    yv   <= r.yv;
    tout <= r.t;
    
    if ap_rst_n = '0' then
      v := REG_INIT_C;
    end if;

    r_in <= v;
  end process comb;

  seq : process ( ap_clk ) is
  begin
    if rising_edge(ap_clk) then
      r <= r_in;
    end if;
  end process seq;

end behav;
